#!/bin/sh
# vim: set filetype=sh:

################################################################################
# Purpose:   Provide helper script to work with ZFS pools, vdevs, and devices
# Args/Opts: See usage (run with -h option).
# Meta:      Script installed by ansible {{ role_name | basename }}.
# Style:     ENV_VAR, GLOBAL_VAR, GLOBAL_READONLY_VAR, func_local_var, my_func
# Refs:      https://docs.freebsd.org/en/books/handbook/zfs/
#            https://docs.freebsd.org/en/books/handbook/disks/
################################################################################

# GLOBAL VARS:

# Constants
PROG_NAME="$(basename "${0}")"
readonly PROG_NAME
DEFAULT_POOL='{{ cfg_zfs_hw_default_pool }}'
readonly DEFAULT_POOL
DEFAULT_PERM_MOUNT_POINT_BASE='{{ cfg_zfs_hw_default_permanent_base_mount_dir }}'
readonly DEFAULT_PERM_MOUNT_POINT_BASE
DEFAULT_TEMP_MOUNT_POINT_BASE='{{ cfg_zfs_hw_default_temp_base_mount_dir }}'
readonly DEFAULT_TEMP_MOUNT_POINT_BASE

# Mutable User Normal Cmd Option Selections
PRINT_HELP_MENU='false'
LIST_POOLS_STATUS='false'
CREATE_STORAGE_POOL='false'
ATTACH_NEW_DISK_TO_BOOT_MIRROR='false'
ATTACH_NEW_DISK_TO_STORAGE_MIRROR='false'
DETACH_DISK_FROM_MIRROR='false'
ADD_VDEV_TO_STORAGE_POOL='false'
ADD_READ_CACHE_DISK_TO_POOL='false'
REMOVE_READ_CACHE_DISK_FROM_POOL='false'
ADD_WRITE_CACHE_DISK_TO_POOL='false'
ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR='false'
REMOVE_WRITE_CACHE_VDEV_FROM_POOL='false'
LABEL_DEVICES_IN_INSTALL_MIRROR='false'
LIST_IMPORTABLE_POOLS='false'
IMPORT_POOL='false'
EXPORT_POOL='false'
SCRUB_POOL_DATA='false'

# Mutable User Contingency Cmd Option Selections
OFFLINE_DEVICE_FROM_POOL='false'
ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR='false'
ATTACH_DEVICE_AS_IS_TO_MIRROR='false'
ONLINE_DEVICE_INTO_POOL='false'
DETACH_DEVICE_FROM_MIRROR='false'
REMOVE_VDEV_FROM_POOL='false'
DESTROY_POOL='false'

# Mutable User Options
GPT_LABEL_PATH=""
ZFS_DEVICE_PATH=""
NON_ZFS_DEVICE_PATH=""
NEW_DISK_PATH=""
ZFS_VDEV=""
PERM_MOUNT_POINT=""
ENCRYPTION_PASSWORD=""
IGNORE_IMPORT_ERRORS='false'
TEMP_POOL_NAME=""
POOL="${DEFAULT_POOL}"

# LOCAL FUNCTIONS:

print_usage() {
  prog_name_num_chars="$(printf "%s" "${PROG_NAME}" | wc -m)"
  leading_indent=''
  i=0
  while [ "${i}" -lt "${prog_name_num_chars}" ]; do
    leading_indent="${leading_indent} "
    i=$((i + 1))
  done

  perm_mountpt="${DEFAULT_PERM_MOUNT_POINT_BASE}/pool_name/"
  temp_mountpt="${DEFAULT_TEMP_MOUNT_POINT_BASE}/temp_name/"

  printf "NORMAL OPERATIONS:\n"
  printf "  %s  -h|--help\n" "${PROG_NAME}"
  printf "  %s  -l|--list-pools-status\n" "${PROG_NAME}"
  printf "  %s  -c|--create-storage-pool                -K <new_disk_path>                        [-M <path>]   -P <pool_name>\n" "${PROG_NAME}"
  printf "  %s  -b|--attach-new-disk-to-boot-mirror     -K <new_disk_path>  -L <gpt_label_path>   [-E <pswd>]  [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -s|--attach-new-disk-to-storage-mirror  -K <new_disk_path>  -L <gpt_label_path>                [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -d|--detach-disk-from-mirror                                -L <gpt_label_path>                [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -v|--add-vdev-to-storage-pool           -K <new_disk_path>                                     [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -r|--add-read-cache-disk-to-pool        -K <new_disk_path>                                     [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -x|--remove-read-cache-disk-from-pool                       -L <gpt_label_path>                [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -w|--add-write-cache-disk-to-pool       -K <new_disk_path>                                     [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -n|--attach-new-disk-to-wcache-mirror   -K <new_disk_path>  -L <gpt_label_path>                [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -y|--remove-write-cache-vdev-from-pool                      -V <vdev_name>                     [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -j|--label-devices-in-install-mirror    -V <vdev_name>                                         [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -g|--list-importable-pools\n" "${PROG_NAME}"
  printf "  %s  -i|--import-pool                                            [-R]                  [-N]          -P <pool_name> \n" "${PROG_NAME}"
  printf "  %s  -e|--export-pool                                                                                -P <pool_name> \n" "${PROG_NAME}"
  printf "  %s  -u|--scrub-pool-data                                                                           [-P <pool_name>]\n" "${PROG_NAME}"
  printf "CONTINGENCY OPERATIONS:\n"
  printf "  %s  --offline-device-from-pool                                  -C <zfs_device_path>               [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  --attach-new-disk-to-install-mirror     -K <new_disk_path>  -C <zfs_device_path>  [-E <pswd>]  [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  --attach-device-as-is-to-mirror         -T <device_path>    -C <zfs_device_path>               [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  --online-device-into-pool                                   -C <zfs_device_path>               [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  --detach-device-from-mirror                                 -C <zfs_device_path>               [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  --remove-vdev-from-pool                                     -V <vdev_name>                     [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  --destroy-pool                                                                                  -P <pool_name>\n" "${PROG_NAME}"
  printf "DETAILS:\n"
  printf "  -h, --help\n"
  printf "      print this help message\n"
  printf "  -l, --list-pools-status\n"
  printf "      list status of all pools, along with their vdevs and devices\n"
  printf "  -c, --create-storage-pool\n"
  printf "      create a new storage pool from a new whole disk\n"
  printf "  -b, --attach-new-disk-to-boot-mirror\n"
  printf "      format, partition, and attach a new disk to a GPT-labeled device in an boot pool, creating a mirror-vdev\n"
  printf "  -s, --attach-new-disk-to-storage-mirror\n"
  printf "      attach a new disk to a device in a storage pool, creating a mirror-vdev\n"
  printf "  -d, --detach-disk-from-mirror\n"
  printf "      detach a (possibly bad) disk from a mirror (offlines + detaches disk)\n"
  printf "  -v, --add-vdev-to-storage-pool\n"
  printf "      add a new disk to a storage pool, as a single-disk vdev\n"
  printf "  -r, --add-read-cache-disk-to-pool\n"
  printf "      add a new disk to the pool as a Level 2 Adjustable Replacement Cache (do not mirror)\n"
  printf "  -x, --remove-read-cache-disk-from-pool\n"
  printf "      remove a single-disk Level 2 Adjustable Replacement Cache from the pool\n"
  printf "  -w, --add-write-cache-disk-to-pool\n"
  printf "      add a new disk to the pool as a Separate ZFS Intent Log (SLOG) (should be mirrored)\n"
  printf "  -n, --attach-new-disk-to-wcache-mirror\n"
  printf "      attach a new disk to a device in the write-cache vdev, creating a mirror-vdev\n"
  printf "  -y, --remove-write-cache-vdev-from-pool\n"
  printf "      remove the Separate ZFS Intent Log (SLOG) vdev from the pool\n"
  printf "  -j, --label-devices-in-install-mirror\n"
  printf "      reformat install-mirror devices and attach them to mirror by GPT label\n"
  printf "  -g, --list-importable-pools\n"
  printf "      list all exported pools and destroyed pools available for import\n"
  printf "  -i, --import-pool\n"
  printf "      import (and activate) an exported or destroyed pool\n"
  printf "  -e, --export-pool\n"
  printf "      export pool for later importing (i.e. activating) on any zfs system\n"
  printf "  -u, --scrub-pool-data\n"
  printf "      read all data in pool (verifying data checksums), and repair as required\n"
  printf "  --offline-device-from-pool\n"
  printf "      offline a device, without detaching it from a pool\n"
  printf "  --attach-new-disk-to-install-mirror\n"
  printf "      format, partition, and attach a new disk to a device in an install pool, creating a mirror-vdev\n"
  printf "  --attach-device-as-is-to-mirror\n"
  printf "      attach any disk/partition/label to a device in a pool, creating a mirror-vdev\n"
  printf "  --online-device-into-pool\n"
  printf "      online an offline device, making it an active part of a pool\n"
  printf "  --detach-device-from-mirror\n"
  printf "      detach a (possibly bad) device from a mirror (offlines + detaches device)\n"
  printf "  --remove-vdev-from-pool\n"
  printf "      remove a root/storage vdev from a pool (consolidates data, but leaves status artifacts!)\n"
  printf "  --destroy-pool\n"
  printf "      destroy a (possibly active) pool (Note: can actually be imported after destroy)\n"
  printf "  -L <gpt_label_path>, --gpt-label=<gpt_label_path>\n"
  printf "      a GPT-labeled disk partition, that is a device in a zfs vdev\n"
  printf "  -C <zfs_device_path>, --zfs-device=<zfs_device_path>\n"
  printf "      any kind of zfs device in a vdev (whole disk, partition, etc)\n"
  printf "  -T <device_path>, --device=<device_path>\n"
  printf "      any kind of device (whole disk, partition, etc) that is NOT an active zfs device in a vdev\n"
  printf "  -K <disk_path>, --whole-disk=<disk_path>\n"
  printf "      a path to a whole disk\n"
  printf "  -V <vdev_name>, --zfs-vdev=<vdev_name>\n"
  printf "      a zfs vdev (could be single disk, or a mirror containing multiple devices)\n"
  printf "  -M <path>, --permanent-mount-point=<path>\n"
  printf "      path to permanent mount point (default: \"%s\")\n" "${perm_mountpt}"
  printf "  -E <pswd>, --encryption-password=<pswd>\n"
  printf "      a password for FreeBSD-GELI-encrypting the whole disk\n"
  printf "  -R, --ignore-import-errors\n"
  printf "      when importing pool, ignore errors (may lose some recent transactions)\n"
  printf "  -N <temp_name>, --temp-pool-name=<temp_name>\n"
  printf "      when importing pool, give pool a temp name and mount it at \"%s\"\n" "${temp_mountpt}"
  printf "  -P <pool_name>, --pool=<pool_name>\n"
  printf "      specify pool-name or pool-GUID to operate on (default: %s)\n" "${DEFAULT_POOL}"
  printf "EXIT CODES:\n"
  printf "    0  ok\n"
  printf "    1  one or more devices in a pool's vdev is not online\n"
  printf "    5  zfs status/list error\n"
  printf "   10  zfs device detach error\n"
  printf "   20  disk format or partition error\n"
  printf "   60  zfs device online/attach/add error\n"
  printf "   80  zfs pool create error\n"
  printf "  100  zfs pool scrub error\n"
  printf "  120  zfs vdev add/removal error\n"
  printf "  255  usage or options error\n"
}

get_cmd_opts() {
  while getopts ':hlcbsdvrxwnyjgieuL:C:T:K:V:M:E:RN:P:-:' option; do
    short_opt_arg="${OPTARG}"
    case "${option}" in
      h)  handle_print_help_menu ;;
      l)  handle_list_pools_status ;;
      c)  handle_create_storage_pool ;;
      b)  handle_attach_new_disk_to_boot_mirror ;;
      s)  handle_attach_new_disk_to_storage_mirror ;;
      d)  handle_detach_disk_from_mirror ;;
      v)  handle_add_vdev_to_storage_pool ;;
      r)  handle_add_read_cache_disk_to_pool ;;
      x)  handle_remove_read_cache_disk_from_pool ;;
      w)  handle_add_write_cache_disk_to_pool ;;
      n)  handle_attach_new_disk_to_write_cache_mirror ;;
      y)  handle_remove_write_cache_vdev_from_pool ;;
      j)  handle_label_devices_in_install_mirror ;;
      g)  handle_list_importable_pools ;;
      i)  handle_import_pool ;;
      e)  handle_export_pool ;;
      u)  handle_scrub_pool_data ;;
      L)  handle_gpt_label "${short_opt_arg}" ;;
      C)  handle_zfs_device "${short_opt_arg}" ;;
      T)  handle_device "${short_opt_arg}" ;;
      K)  handle_whole_disk "${short_opt_arg}" ;;
      V)  handle_zfs_vdev "${short_opt_arg}" ;;
      M)  handle_permanent_mount_point "${short_opt_arg}" ;;
      E)  handle_encryption_password "${short_opt_arg}" ;;
      R)  handle_ignore_import_errors ;;
      N)  handle_temp_pool_name "${short_opt_arg}" ;;
      P)  handle_pool "${short_opt_arg}" ;;
      -)  long_opt_name="${OPTARG}"
          long_opt_arg="${OPTARG#*=}"
          case ${long_opt_name} in
            help)                                   handle_print_help_menu ;;
            help=*)                                 handle_illegal_long_option_arg "${long_opt_name}" ;;
            list-pools-status)                      handle_list_pools_status ;;
            list-pools-status=*)                    handle_illegal_long_option_arg "${long_opt_name}" ;;
            create-storage-pool)                    handle_create_storage_pool ;;
            create-storage-pool=*)                  handle_illegal_long_option_arg "${long_opt_name}" ;;
            attach-new-disk-to-boot-mirror)         handle_attach_new_disk_to_boot_mirror ;;
            attach-new-disk-to-boot-mirror=*)       handle_illegal_long_option_arg "${long_opt_name}" ;;
            attach-new-disk-to-storage-mirror)      handle_attach_new_disk_to_storage_mirror ;;
            attach-new-disk-to-storage-mirror=*)    handle_illegal_long_option_arg "${long_opt_name}" ;;
            detach-disk-from-mirror)                handle_detach_disk_from_mirror ;;
            detach-disk-from-mirror=*)              handle_illegal_long_option_arg "${long_opt_name}" ;;
            add-vdev-to-storage-pool)               handle_add_vdev_to_storage_pool ;;
            add-vdev-to-storage-pool=*)             handle_illegal_long_option_arg "${long_opt_name}" ;;
            add-read-cache-disk-to-pool)            handle_add_read_cache_disk_to_pool ;;
            add-read-cache-disk-to-pool=*)          handle_illegal_long_option_arg "${long_opt_name}" ;;
            remove-read-cache-disk-from-pool)       handle_remove_read_cache_disk_from_pool ;;
            remove-read-cache-disk-from-pool=*)     handle_illegal_long_option_arg "${long_opt_name}" ;;
            add-write-cache-disk-to-pool)           handle_add_write_cache_disk_to_pool ;;
            add-write-cache-disk-to-pool=*)         handle_illegal_long_option_arg "${long_opt_name}" ;;
            attach-new-disk-to-wcache-mirror)       handle_attach_new_disk_to_write_cache_mirror ;;
            attach-new-disk-to-wcache-mirror=*)     handle_illegal_long_option_arg "${long_opt_name}" ;;
            remove-write-cache-vdev-from-pool)      handle_remove_write_cache_vdev_from_pool ;;
            remove-write-cache-vdev-from-pool=*)    handle_illegal_long_option_arg "${long_opt_name}" ;;
            label-devices-in-install-mirror)        handle_label_devices_in_install_mirror ;;
            label-devices-in-install-mirror=*)      handle_illegal_long_option_arg "${long_opt_name}" ;;
            list-importable-pools)                  handle_list_importable_pools ;;
            list-importable-pools=*)                handle_illegal_long_option_arg "${long_opt_name}" ;;
            import-pool)                            handle_import_pool ;;
            import-pool=*)                          handle_illegal_long_option_arg "${long_opt_name}" ;;
            export-pool)                            handle_export_pool ;;
            export-pool=*)                          handle_illegal_long_option_arg "${long_opt_name}" ;;
            scrub-pool-data)                        handle_scrub_pool_data ;;
            scrub-pool-data=*)                      handle_illegal_long_option_arg "${long_opt_name}" ;;
            offline-device-from-pool)               handle_offline_device_from_pool ;;
            offline-device-from-pool=*)             handle_illegal_long_option_arg "${long_opt_name}" ;;
            attach-new-disk-to-install-mirror)      handle_attach_new_disk_to_install_mirror ;;
            attach-new-disk-to-install-mirror=*)    handle_illegal_long_option_arg "${long_opt_name}" ;;
            attach-device-as-is-to-mirror)          handle_attach_device_as_is_to_mirror ;;
            attach-device-as-is-to-mirror=*)        handle_illegal_long_option_arg "${long_opt_name}" ;;
            online-device-into-pool)                handle_online_device_into_pool ;;
            online-device-into-pool=*)              handle_illegal_long_option_arg "${long_opt_name}" ;;
            detach-device-from-mirror)              handle_detach_device_from_mirror ;;
            detach-device-from-mirror=*)            handle_illegal_long_option_arg "${long_opt_name}" ;;
            remove-vdev-from-pool)                  handle_remove_vdev_from_pool ;;
            remove-vdev-from-pool=*)                handle_illegal_long_option_arg "${long_opt_name}" ;;
            destroy-pool)                           handle_destroy_pool ;;
            destroy-pool=*)                         handle_illegal_long_option_arg "${long_opt_name}" ;;
            gpt-label=?*)                           handle_gpt_label "${long_opt_arg}" ;;
            gpt-label*)                             handle_missing_long_option_arg "${long_opt_name}" ;;
            zfs-device=?*)                          handle_zfs_device "${long_opt_arg}" ;;
            zfs-device*)                            handle_missing_long_option_arg "${long_opt_name}" ;;
            device=?*)                              handle_device "${long_opt_arg}" ;;
            device*)                                handle_missing_long_option_arg "${long_opt_name}" ;;
            whole-disk=?*)                          handle_whole_disk "${long_opt_arg}" ;;
            whole-disk*)                            handle_missing_long_option_arg "${long_opt_name}" ;;
            zfs-vdev=?*)                            handle_zfs_vdev "${long_opt_arg}" ;;
            zfs-vdev*)                              handle_missing_long_option_arg "${long_opt_name}" ;;
            permanent-mount-point=?*)               handle_permanent_mount_point "${long_opt_arg}" ;;
            permanent-mount-point*)                 handle_missing_long_option_arg "${long_opt_name}" ;;
            encryption-password=?*)                 handle_encryption_password "${long_opt_arg}" ;;
            encryption-password*)                   handle_missing_long_option_arg "${long_opt_name}" ;;
            ignore-import-errors)                   handle_ignore_import_errors ;;
            ignore-import-errors=*)                 handle_illegal_long_option_arg "${long_opt_name}" ;;
            temp-pool-name=?*)                      handle_temp_pool_name "${long_opt_arg}" ;;
            temp-pool-name*)                        handle_missing_long_option_arg "${long_opt_name}" ;;
            pool=?*)                                handle_pool "${long_opt_arg}" ;;
            pool*)                                  handle_missing_long_option_arg "${long_opt_name}" ;;
            '')                                     break ;; # non-option arg starting with '-'
            *)                                      handle_unknown_option "${long_opt_name}" ;;
          esac ;;
      \?) handle_unknown_option "${short_opt_arg}" ;;
    esac
  done
}

exit_with_cleanup() {
  err_code="${1}"
  exit "${err_code}"
}

print_err_msg() {
  err_msg="${1}"
  printf "ERROR:\n%s: %s\n" "${PROG_NAME}" "${err_msg}"
}

quit_with_err_msg() {
  err_msg="${1}"
  err_code="${2}"
  print_err_msg "${err_msg}"
  exit_with_cleanup "${err_code}"
}

quit_if_rc_not_zero() {
  cmd_exit_code="${1}"
  err_msg="${2}"
  script_exit_code="${3}"
  if [ "${cmd_exit_code}" != 0  ]; then
    quit_with_err_msg "${err_msg}" "${script_exit_code}"
  fi
}

try_silent_with_exit() {
  cmd="${1}"
  err_msg="${2}"
  err_code="${3}"

  eval "${cmd}"
  exit_code="${?}"
  if [ "${exit_code}" != 0 ]; then
    quit_with_err_msg "${err_msg}" "${err_code}"
  fi
}

try_silent_print_with_exit() {
  cmd="${1}"
  op_descrip="${2}"
  err_code="${3}"

  printf "Now %s with \"%s\"...\n" "${op_descrip}" "${cmd}"
  err_msg="error ${op_descrip}"
  try_silent_with_exit \
    "${cmd}" \
    "${err_msg}" "${err_code}"
}

try_total_silent_with_exit() {
  cmd="${1}"
  op_descrip="${2}"

  printf "Now %s with \"%s\"...\n" "${op_descrip}" "${cmd}"
  eval "${cmd}" 1> /dev/null 2>&1
}

handle_unknown_option() {
  short_opt_letter_or_long_opt_name="${1}"
  err_msg="unknown option \"${short_opt_letter_or_long_opt_name}\""
  quit_with_err_msg "${err_msg}" 255
}

handle_illegal_long_option_arg() {
  long_opt_name="${1}"
  err_msg="illegal argument in \"${long_opt_name}\""
  quit_with_err_msg "${err_msg}" 255
}

handle_missing_long_option_arg() {
  long_opt_name="${1}"
  err_msg="missing argument for option \"${long_opt_name}\""
  quit_with_err_msg "${err_msg}" 255
}

handle_print_help_menu() {
  if [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  PRINT_HELP_MENU='true'
}

handle_list_pools_status() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  LIST_POOLS_STATUS='true'
}

handle_create_storage_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  CREATE_STORAGE_POOL='true'
}

handle_attach_new_disk_to_boot_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  ATTACH_NEW_DISK_TO_BOOT_MIRROR='true'
}

handle_attach_new_disk_to_storage_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  ATTACH_NEW_DISK_TO_STORAGE_MIRROR='true'
}

handle_detach_disk_from_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  DETACH_DISK_FROM_MIRROR='true'
}

handle_add_vdev_to_storage_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  ADD_VDEV_TO_STORAGE_POOL='true'
}

handle_add_read_cache_disk_to_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  ADD_READ_CACHE_DISK_TO_POOL='true'
}

handle_remove_read_cache_disk_from_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  REMOVE_READ_CACHE_DISK_FROM_POOL='true'
}

handle_add_write_cache_disk_to_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  ADD_WRITE_CACHE_DISK_TO_POOL='true'
}

handle_attach_new_disk_to_write_cache_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR='true'
}

handle_remove_write_cache_vdev_from_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  REMOVE_WRITE_CACHE_VDEV_FROM_POOL='true'
}

handle_list_importable_pools() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  LIST_IMPORTABLE_POOLS='true'
}

handle_import_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  IMPORT_POOL='true'
}

handle_export_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  EXPORT_POOL='true'
}

handle_scrub_pool_data() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  SCRUB_POOL_DATA='true'
}

handle_label_devices_in_install_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  LABEL_DEVICES_IN_INSTALL_MIRROR='true'
}

handle_offline_device_from_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  OFFLINE_DEVICE_FROM_POOL='true'
}

handle_attach_new_disk_to_install_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR='true'
}

handle_attach_device_as_is_to_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  ATTACH_DEVICE_AS_IS_TO_MIRROR='true'
}

handle_online_device_into_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  ONLINE_DEVICE_INTO_POOL='true'
}

handle_detach_device_from_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  DETACH_DEVICE_FROM_MIRROR='true'
}

handle_remove_vdev_from_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${DESTROY_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  REMOVE_VDEV_FROM_POOL='true'
}

handle_destroy_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ] || \
     [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ] || \
     [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ] || \
     [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ] || \
     [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ] || \
     [ "${LIST_IMPORTABLE_POOLS}" = 'true' ] || \
     [ "${IMPORT_POOL}" = 'true' ] || \
     [ "${EXPORT_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ] || \
     [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ] || \
     [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 255
  fi
  DESTROY_POOL='true'
}

handle_gpt_label() {
  GPT_LABEL_PATH="${1}"
}

handle_zfs_device() {
  ZFS_DEVICE_PATH="${1}"
}

handle_device() {
  NON_ZFS_DEVICE_PATH="${1}"
}

handle_whole_disk() {
  NEW_DISK_PATH="${1}"
}

handle_zfs_vdev() {
  ZFS_VDEV="${1}"
}

handle_permanent_mount_point() {
  PERM_MOUNT_POINT="${1}"
}

handle_encryption_password() {
  ENCRYPTION_PASSWORD="${1}"
}

handle_ignore_import_errors() {
  IGNORE_IMPORT_ERRORS='true'
}

handle_temp_pool_name() {
  TEMP_POOL_NAME="${1}"
}

handle_pool() {
  POOL="${1}"
}

validate_whole_disk_name_or_path() {
  whole_disk_name_or_path="${1}"

  try_silent_with_exit \
    "camcontrol identify ${whole_disk_name_or_path} 1> /dev/null 2>&1" \
    "\"${whole_disk_name_or_path}\" must be a valid whole disk" 255
}

validate_string_is_unsigned_integer() {
  str="${1}"

  try_silent_with_exit \
    "test ! -z ${str}" \
    "\"${str}\" must not be an empty string" 255
  try_silent_with_exit \
    "test \"${str}\" -eq \"${str}\"" \
    "\"${str}\" must be an unsigned integer" 255
}

validate_partition_without_extension() {
  # Note: this may be a basename or path, but must not have a file extension
  partition="${1}"

  part_name="$(print_filename_without_extension "${partition}")"

  try_silent_with_exit \
    "geom part status -s | tr -s ' ' | cut -d' ' -f1 | grep ${part_name} 1> /dev/null 2>&1" \
    "\"${part_name}\" must be a valid partition" 255
}

validate_active_device_in_vdev() {
  device="${1}"
  pool="${2}"

  try_silent_with_exit \
    "zpool list -v -P ${pool} | grep --regexp=\"\s${device}\s\" 1> /dev/null" \
    "\"${device}\" must be an active zfs device in a vdev in pool \"${pool}\"" 255
}

validate_not_active_device_in_vdev() {
  device="${1}"

  try_silent_with_exit \
    "! zpool list -v -P | grep \"${device}\" 1> /dev/null" \
    "\"${device}\" must not be an active zfs device in a vdev" 255
}

validate_not_active_non_cache_device_in_vdev() {
  device_path="${1}"
  pool="${2}"

  try_silent_with_exit \
    "! zpool get -H -p -o value path ${pool} all-vdevs 2> /dev/null | grep \"${device_path}\" 1> /dev/null 2>&1" \
    "disk \"${device_path}\" is a normal zfs device in pool \"${pool}\" - not a read/write cache disk" 255
}

validate_item_is_full_disk() {
  item="${1}"

  try_silent_with_exit \
    "camcontrol identify ${item} 1> /dev/null 2>&1" \
    "\"${item}\" must be a full disk, not a disk partition" 255
}

validate_item_is_not_full_disk() {
  item="${1}"

  try_silent_with_exit \
    "! camcontrol identify ${item} 1> /dev/null 2>&1" \
    "\"${item}\" must be a partition, not a path to a full disk" 255
}

validate_file_has_extension() {
  filename_or_file_path="${1}"
  file_extension="${2}"
  err_msg="${3}"

  try_silent_with_exit \
    "test \"${filename_or_file_path##*.}\" = \"${file_extension}\"" \
    "${err_msg}" 255
}

validate_file_has_no_extension() {
  filename_or_file_path="${1}"
  err_msg="${2}"

  filename_or_file_path_ext_removed="${filename_or_file_path%.*}"
  try_silent_with_exit \
    "test \"${filename_or_file_path_ext_removed}\" = \"${filename_or_file_path}\"" \
    "${err_msg}" 255
}

validate_zfs_geli_ecrypted_partition() {
  path_to_zfs_geli_enc_part="${1}"
  err_msg="${2}"

  try_silent_with_exit \
    "geli status \"${path_to_zfs_geli_enc_part}\" 1> /dev/null 2>&1" \
    "${err_msg}" 255
}

validate_zfs_or_zfs_geli_partition() {
  path_to_part="${1}"
  err_msg="${2}"

  part_name="$(print_filename_without_extension "${path_to_part}")"

  try_silent_with_exit \
    "gpart show -p | grep ${part_name} | grep zfs 1> /dev/null 2>&1" \
    "${err_msg}" 255
}

validate_gpt_partition_label() {
  part_label_path="${1}"

  try_silent_with_exit \
    "test -z \"${part_label_path##/dev/gpt/*}\"" \
    "GPT partition label \"${part_label_path}\" is not a partition" 255
  try_silent_with_exit \
    "test -e \"${part_label_path}\"" \
    "GPT partition label \"${part_label_path}\" does not exist in filesystem" 255
}

validate_not_gpt_partition_label() {
  path="${1}"

  try_silent_with_exit \
    "! test -z \"${path##/dev/gpt/*}\"" \
    "GPT partition label \"${path}\" should not exist" 255
}

validate_zfs_vdev() {
  vdev_name="${1}"
  pool="${2}"

  try_silent_with_exit \
    "zpool get -H -o value parent ${pool} ${vdev_name} 2> /dev/null | grep ${pool} 1> /dev/null 2>&1" \
    "\"${vdev_name}\" is not a top-level single-disk or mirrror vdev of pool \"${pool}\"" 255
}

validate_pool_has_read_cache_disk() {
  pool="${1}"

  read_cache_vdev_name="cache"
  try_silent_with_exit \
    "zpool list -v -o name ${pool} 2> /dev/null | cut -d' ' -f1 | grep ${read_cache_vdev_name} 1> /dev/null 2>&1" \
    "read cache does not exist in pool \"${pool}\" (did you specify the correct pool?)" 255
}

validate_pool_has_write_cache_disk() {
  pool="${1}"

  write_cache_vdev_name="log"
  try_silent_with_exit \
    "zpool list -v -o name ${pool} 2> /dev/null | cut -d' ' -f1 | grep ${write_cache_vdev_name} 1> /dev/null 2>&1" \
    "write cache does not exist in pool \"${pool}\" (did you specify the correct pool?)" 255
}

check_running_as_root() {
  if [ "$(id -un)" != 'root' ]; then
    quit_with_err_msg "must run this script as root for this operation" 255
  fi
}

check_gpt_label_option() {
  if [ "${GPT_LABEL_PATH}" = '' ]; then
    quit_with_err_msg "\"--gpt-label\" option must be specified" 255
  fi
  validate_gpt_partition_label "${GPT_LABEL_PATH}"
}

check_zfs_device_option() {
  if [ "${ZFS_DEVICE_PATH}" = '' ]; then
    quit_with_err_msg "\"--zfs-device\" option must be specified" 255
  fi
  validate_active_device_in_vdev "${ZFS_DEVICE_PATH}" "${POOL}"
}

check_device_option() {
  if [ "${NON_ZFS_DEVICE_PATH}" = '' ]; then
    quit_with_err_msg "\"--device\" option must be specified" 255
  fi
  validate_not_active_device_in_vdev "${NON_ZFS_DEVICE_PATH}"
}

check_zfs_device_option_is_not_specified() {
  if [ "${ZFS_DEVICE_PATH}" != '' ]; then
    quit_with_err_msg "\"--zfs-device\" option must not be specified for this operation" 255
  fi
}

check_whole_disk_option() {
  if [ "${NEW_DISK_PATH}" = '' ]; then
    quit_with_err_msg "\"--whole-disk\" option must be specified" 255
  fi
  validate_whole_disk_name_or_path "${NEW_DISK_PATH}"
}

check_vdev_option() {
  if [ "${ZFS_VDEV}" = '' ]; then
    quit_with_err_msg "\"--zfs-vdev\" option must be specified" 255
  fi

  validate_zfs_vdev "${ZFS_VDEV}" "${POOL}"
}

check_pool_option_is_boot_pool() {
  pool="${1}"

  pool_mounted_on_root_dir="$(zfs get -H -o name mountpoint '/' | awk -F '/' '{print $1}')"
  if [ "${pool}" != "${pool_mounted_on_root_dir}" ]; then
    quit_with_err_msg "pool must be the zfs root/boot pool" 255
  fi
}

check_pool_option_is_not_boot_pool() {
  pool="${1}"

  pool_mounted_on_root_dir="$(zfs get -H -o name mountpoint '/' | awk -F '/' '{print $1}')"
  if [ "${pool}" = "${pool_mounted_on_root_dir}" ]; then
    quit_with_err_msg "pool must be a storage pool, NOT the zfs root/boot pool" 255
  fi
}

check_encrypt_pswd_option_supplied_if_req() {
  path="${1}"
  long_opt_name="${2}"

  if [ "${ENCRYPTION_PASSWORD}" = '' ]; then
    validate_file_has_no_extension \
      "${path}" \
      "since --encryption-password was not supplied, ${long_opt_name} should not have a .eli extension"
  else
    validate_file_has_extension \
      "${path}" \
      "eli" \
      "since --encryption-password was supplied, ${long_opt_name} should have a .eli extension"
    validate_zfs_geli_ecrypted_partition \
      "${path}" \
      "since --encryption-password was supplied, ${long_opt_name} should be a GELI-encrypted partition"
  fi
}

check_encrypt_pswd_option_is_not_specified() {
  if [ "${ENCRYPTION_PASSWORD}" != '' ]; then
    quit_with_err_msg "--encryption-password is not supported for this operation" 255
  fi
}

print_filename_without_extension() {
  path_to_file="${1}"

  # Note: this handles a filename with or without an extension
  basename -- "${path_to_file}" ".${path_to_file##*.}"
}

print_legacy_bios_partition_number() {
  path_to_whole_disk="${1}"

  # Note: part number should be e.g. "1"
  part_number="$(gpart show "${path_to_whole_disk}" | tr -s ' ' | grep --only-matching --regexp='[0-9] freebsd-boot' | cut -d' ' -f1)"
  validate_string_is_unsigned_integer "${part_number}"
  printf "%s" "${part_number}"
}

print_uefi_partition_number() {
  path_to_whole_disk="${1}"

  # Note: part number should be e.g. "1"
  part_number="$(gpart show "${path_to_whole_disk}" | tr -s ' ' | grep --only-matching --regexp='[0-9] efi' | cut -d' ' -f1)"
  validate_string_is_unsigned_integer "${part_number}"
  printf "%s" "${part_number}"
}

print_swap_partition_number() {
  path_to_whole_disk="${1}"

  # Note: part number should be e.g. "1"
  part_number="$(gpart show "${path_to_whole_disk}" | tr -s ' ' | grep --only-matching --regexp='[0-9] freebsd-swap' | cut -d' ' -f1)"
  validate_string_is_unsigned_integer "${part_number}"
  printf "%s" "${part_number}"
}

print_zfs_partition_number() {
  path_to_whole_disk="${1}"

  # Note: part number should be e.g. "1"
  part_number="$(gpart show "${path_to_whole_disk}" | tr -s ' ' | grep --only-matching --regexp='[0-9] freebsd-zfs' | cut -d' ' -f1)"
  validate_string_is_unsigned_integer "${part_number}"
  printf "%s" "${part_number}"
}

print_path_to_zfs_partition_without_eli_ext() {
  path_to_whole_disk="${1}"

  # Note: part name should be e.g. "ada1p3"
  # Note: find the partition type with the zfs partition code
  part_name="$(gpart show -p "${path_to_whole_disk}" | tr -s ' ' | grep --only-matching --regexp='\w* freebsd-zfs' | cut -d' ' -f1)"
  validate_partition_without_extension "${part_name}"
  printf "%s" "/dev/${part_name}"
}

print_path_to_zfs_geli_ecrypted_partition() {
  path_to_whole_disk="${1}"

  path_to_part_without_geli_ext="$(print_path_to_zfs_partition_without_eli_ext "${path_to_whole_disk}")"

  path_to_zfs_geli_enc_part="${path_to_part_without_geli_ext}.eli"
  validate_zfs_geli_ecrypted_partition \
    "${path_to_zfs_geli_enc_part}" \
    "\"${path_to_zfs_geli_enc_part}\" is not a valid GELI-encrypted partition"
  printf "%s" "${path_to_zfs_geli_enc_part}"
}

print_part_path_from_label() {
  gpt_label_path="${1}"

  gpt_label_name="$(print_filename_without_extension "${gpt_label_path}")"
  part_name="$(gpart show -lp | grep "${gpt_label_name}" | awk '{ print $3 }')"
  validate_partition_without_extension "${part_name}"
  printf "%s" "/dev/${part_name}"
}

print_whole_disk_name() {
  whole_disk_path="${1}"

  whole_disk_name="$(basename "${whole_disk_path}")"
  validate_whole_disk_name_or_path "${whole_disk_name}"
  printf "%s" "${whole_disk_name}"
}

print_whole_disk_path() {
  # Note: this may be partition name, path to partition, with/without extension
  part_name_or_part_path="${1}"

  if [ -z "${part_name_or_part_path##/dev/gpt/*}" ]; then
    actual_part="$(print_part_path_from_label "${part_name_or_part_path}")"
  else
    actual_part="${part_name_or_part_path}"
  fi

  part_name_without_ext="$(print_filename_without_extension "${actual_part}")"
  whole_disk_name="$(geom part status -s | grep "${part_name_without_ext}" | tr -s ' ' | cut -d' ' -f3)"
  path_to_whole_disk="/dev/${whole_disk_name}"
  validate_whole_disk_name_or_path "${path_to_whole_disk}"
  printf "%s" "${path_to_whole_disk}"
}

print_perm_mount_point() {
  perm_mount_point_base="${1}"
  user_specified_perm_mount_point="${2}"
  pool="${3}"

  if [ "${user_specified_perm_mount_point}" = '' ]; then
    printf "%s/%s" "${perm_mount_point_base}" "${pool}"
  else
    printf "%s" "${user_specified_perm_mount_point}"
  fi
}

print_disk_type_prefix() {
  disk_path="${1}"

  whole_disk_name="$(print_whole_disk_name "${disk_path}")"
  disk_type="$(printf "%s" "${whole_disk_name}" | cut -c -3)"
  printf "%s" "${disk_type}"
}

print_base_gpt_partition_label() {
  disk_path="${1}"

  whole_disk_name="$(print_whole_disk_name "${disk_path}")"
  short_disk_type="$(printf "%s" "${whole_disk_name}" | cut -c -2)"
  serno="$(diskinfo -s "${disk_path}" | tail -c 6)"
  printf "%s" "${short_disk_type}${serno}"
}

print_gpt_legacy_bios_part_label() {
  disk_path="${1}"

  gpt_part_label="$(print_base_gpt_partition_label "${disk_path}")"

  printf "%s" "b-${gpt_part_label}"
}

print_gpt_uefi_part_label() {
  disk_path="${1}"

  gpt_part_label="$(print_base_gpt_partition_label "${disk_path}")"

  printf "%s" "e-${gpt_part_label}"
}

print_efibootmgr_label() {
  disk_path="${1}"

  base_label="$(print_base_gpt_partition_label "${disk_path}")"

  printf "%s" "FreeBSD OS Disk ${base_label}"
}

print_gpt_swap_part_label() {
  disk_path="${1}"

  gpt_part_label="$(print_base_gpt_partition_label "${disk_path}")"

  printf "%s" "s-${gpt_part_label}"
}

print_gpt_zfs_part_label() {
  disk_path="${1}"

  gpt_part_label="$(print_base_gpt_partition_label "${disk_path}")"

  printf "%s" "z-${gpt_part_label}"
}

print_gpt_zfs_part_label_path() {
  disk_path="${1}"

  gpt_part_label_path="/dev/gpt/$(print_gpt_zfs_part_label "${disk_path}")"
  validate_gpt_partition_label "${gpt_part_label_path}"
  printf "%s" "${gpt_part_label_path}"
}

print_enc_mod_gpt_partition_label_path() {
  gpt_part_label_path="${1}"

  if [ "${ENCRYPTION_PASSWORD}" = '' ]; then
    mod_path="${gpt_part_label_path}"
  else
    mod_path="${gpt_part_label_path}.eli"
  fi

  printf "%s" "${mod_path}"
}

detach_disk_geli_device_as_required() {
  disk_path="${1}"

  disk_name="$(print_whole_disk_name "${disk_path}")"
  geli_device_name="$(geli status 2> /dev/null | grep "${disk_name}" | tr -s ' ' | awk '{ print $1 }')"

  if [ "${geli_device_name}" != '' ]; then
    try_silent_print_with_exit \
      "geli detach ${geli_device_name}" \
      "detaching geli device" 20
  fi
}

disable_all_system_swap_devices() {
  active_swap_devices="$(swapctl -l | tail -n +2 | cut -d' ' -f1)"

  printf "%s\n" "${active_swap_devices}" | while IFS="$(printf "\n.")" read -r swap_device; do
    try_silent_print_with_exit \
      "swapoff \"${swap_device}\"" \
      "disabling swap device \"${swap_device}\"" 20
  done
}

wipe_new_disk_as_required() {
  new_whole_disk_path="${1}"

  detach_disk_geli_device_as_required "${new_whole_disk_path}"
  disable_all_system_swap_devices

  try_silent_print_with_exit \
    "gpart destroy -F ${new_whole_disk_path}" \
    "wiping new disk's partition table"
}

create_single_zfs_partition() {
  new_whole_disk_path="${1}"

  try_silent_print_with_exit \
    "gpart create -s gpt ${new_whole_disk_path}" \
    "creating partition table on ${new_whole_disk_path}" 20

  gpt_part_label="$(print_gpt_zfs_part_label "${new_whole_disk_path}")"
  try_silent_print_with_exit \
    "gpart add -t freebsd-zfs -l ${gpt_part_label} ${new_whole_disk_path}" \
    "creating single ZFS partition on ${new_whole_disk_path}" 20
}

label_existing_zfs_partition() {
  new_whole_disk_path="${1}"

  zfs_partition_number="$(print_zfs_partition_number "${new_whole_disk_path}")"
  gpt_part_label="$(print_gpt_zfs_part_label "${new_whole_disk_path}")"
  try_silent_print_with_exit \
    "gpart modify -i ${zfs_partition_number} -l ${gpt_part_label} ${new_whole_disk_path}" \
    "labeling ZFS partition on ${new_whole_disk_path}" 20
}

format_partitions_on_new_root_mirror_disk() {
  new_whole_disk_path="${1}"
  # Note: may be disk partition, or GPT label pointing to disk partition
  existing_zfs_part_device_path="${2}"

  try_silent_print_with_exit \
    "gpart create -s gpt ${new_whole_disk_path}" \
    "creating partition table on ${new_whole_disk_path}" 20

  existing_whole_disk="$(print_whole_disk_path "${existing_zfs_part_device_path}")"
  part_table_path="/tmp/existing_part_table.txt"

  try_silent_print_with_exit \
    "gpart backup ${existing_whole_disk} > ${part_table_path}" \
    "copying existing disk's partition-table-format to ${part_table_path}" 20

  try_silent_print_with_exit \
    "gpart restore -F ${new_whole_disk_path} < ${part_table_path}" \
    "writing partition table to new disk" 20
}

configure_legacy_bios_partition() {
  # ref: https://wiki.freebsd.org/RootOnZFS/GPTZFSBoot
  whole_disk_path="${1}"

  partition_number="$(print_legacy_bios_partition_number "${whole_disk_path}")"

  gpt_part_label="$(print_gpt_legacy_bios_part_label "${whole_disk_path}")"
  try_silent_print_with_exit \
    "gpart modify -i ${partition_number} -l ${gpt_part_label} ${whole_disk_path}" \
    "labeling legacy BIOS partition ${partition_number} on ${whole_disk_path}" 20

  try_silent_print_with_exit \
    "gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i ${partition_number} ${whole_disk_path}" \
    "setting legacy BIOS bootcode on new disk partition ${partition_number}" 20
}

configure_efi_bootmgr() {
  # ref: https://man.freebsd.org/cgi/man.cgi?query=efibootmgr
  whole_disk_path="${1}"
  efi_install_dir="${2}/efi"

  gpt_uefi_part_label="$(print_gpt_uefi_part_label "${whole_disk_path}")"
  efibootmgr_label="$(print_efibootmgr_label "${whole_disk_path}")"

  search_str="Boot[0-9][0-9][0-9][0-9].*${efibootmgr_label}"
  existing_efi_var_num="$(efibootmgr -v | grep --only-matching --regexp="${search_str}" | cut -c 5-8)"

  if [ "${existing_efi_var_num}" != '' ]; then
    try_silent_print_with_exit \
      "efibootmgr --delete -b ${existing_efi_var_num}" \
      "deleting existing EFI var for EFI label ${efibootmgr_label}" 20
  fi

  loader_exec="${efi_install_dir}/efi/freebsd/loader.efi"
  try_silent_print_with_exit \
    "efibootmgr -a -c -l \"${loader_exec}\" -L \"${efibootmgr_label}\"" \
    "registering EFI loader \"${loader_exec}\" with efibootmgr" 20
}

configure_uefi_etc_fstab_entry() {
  whole_disk_path="${1}"

  # Note: always mount EFI partition from disk0
  disk_type_prefix="$(print_disk_type_prefix "${whole_disk_path}")"
  uefi_part_number="$(print_uefi_partition_number "${whole_disk_path}")"
  disk0_uefi_part_basename="${disk_type_prefix}p${uefi_part_number}"

  try_silent_print_with_exit \
    "sed -i '' '/\/dev\/gpt\/efiboot/d' /etc/fstab" \
    "Removing any efi partition /etc/fstab entries added by FreeBSD installer" 20

  try_silent_print_with_exit \
    "sed -i '' '/\/dev\/${disk0_uefi_part_basename}/d' /etc/fstab" \
    "Removing any existing /etc/fstab swap entry for /dev/${disk0_uefi_part_basename}" 20

  try_silent_print_with_exit \
    "echo '/dev/${disk0_uefi_part_basename} /boot/efi msdosfs rw 2 2' >> /etc/fstab" \
    "Adding ${disk0_uefi_part_basename} efi partition entry to /etc/fstab" 20
}

configure_uefi_partition() {
  # ref: https://wiki.freebsd.org/RootOnZFS/GPTZFSBoot
  # ref: https://man.freebsd.org/cgi/man.cgi?query=boot1.efi&sektion=8&manpath=freebsd-release-ports
  whole_disk_path="${1}"

  uefi_part_number="$(print_uefi_partition_number "${whole_disk_path}")"
  gpt_uefi_part_label="$(print_gpt_uefi_part_label "${whole_disk_path}")"
  uefi_partition_path="${whole_disk_path}p${uefi_part_number}"

  try_silent_print_with_exit \
    "gpart modify -i ${uefi_part_number} -l ${gpt_uefi_part_label} ${whole_disk_path}" \
    "labeling UEFI partition ${uefi_part_number} on ${whole_disk_path}" 20

  try_silent_print_with_exit \
    "newfs_msdos -F 32 -c ${uefi_part_number} ${uefi_partition_path}" \
    "formatting partition ${uefi_part_number} on new disk with FAT32" 20

  temp_efi_mount="/tmp/efi_install_tempmount"

  try_silent_print_with_exit \
    "mkdir -p \"${temp_efi_mount}\"" \
    "creating temp mountpoint \"${temp_efi_mount}\" for EFI partition" 20

  gpt_uefi_part_path="/dev/gpt/${gpt_uefi_part_label}"
  try_silent_print_with_exit \
    "mount -t msdosfs -o longnames \"${gpt_uefi_part_path}\" \"${temp_efi_mount}\"" \
    "mounting EFI partition ${gpt_uefi_part_path} on temp mountpoint \"${temp_efi_mount}\"" 20

  try_silent_print_with_exit \
    "cp -rf \"/boot/efi\" \"${temp_efi_mount}\"" \
    "copying EFI partition content to temp EFI mountpoint" 20

  configure_efi_bootmgr "${whole_disk_path}" "${temp_efi_mount}"

  try_silent_print_with_exit \
    "umount \"${temp_efi_mount}\"" \
    "unmounting EFI partition from temp mountpoint \"${temp_efi_mount}\"" 20

  configure_uefi_etc_fstab_entry "${whole_disk_path}"
}

configure_boot_partitions_on_new_root_mirror_disk() {
  new_whole_disk_path="${1}"

  # Partitions Created With FreeBSD 14.2 on BIOS Hardware:
  #   1. One BIOS part (part type "freebsd-boot")
  # Partitions Created With FreeBSD 14.2 on UEFI Hardware:
  #   1. One EFI part (part type "efi")
  #   2. One BIOS part (part type "freebsd-boot", a just-in-case part)
  # Refs:
  #   https://forums.freebsd.org/threads/update-of-the-bootcodes-for-a-gpt-scheme-x64-architecture.80163/#post-509122
  #   https://forums.freebsd.org/threads/cant-boot-on-uefi.68141/#post-406138

  # Note: per above comments, a UEFI partitioning scheme also has BIOS partition
  configure_legacy_bios_partition "${new_whole_disk_path}"

  bios_type="$(sysctl -n machdep.bootmethod)"
  if [ "${bios_type}" = 'UEFI' ]; then
    configure_uefi_partition "${new_whole_disk_path}"
  fi
}

configure_swap_partition_on_new_root_mirror_disk() {
  new_whole_disk_path="${1}"

  swap_part_number="$(print_swap_partition_number "${whole_disk_path}")"
  gpt_swap_part_label="$(print_gpt_swap_part_label "${whole_disk_path}")"

  try_silent_print_with_exit \
    "gpart modify -i ${swap_part_number} -l ${gpt_swap_part_label} ${whole_disk_path}" \
    "labeling swap partition ${swap_part_number} on ${whole_disk_path}" 20

  try_silent_print_with_exit \
    "sed -i '' '/\/dev\/ad.*swap/d' /etc/fstab" \
    "Removing any /etc/fstab swap entries that use raw ad[n] disk paths" 20

  try_silent_print_with_exit \
    "sed -i '' '/\/dev\/nd.*swap/d' /etc/fstab" \
    "Removing any /etc/fstab swap entries that use raw nd[n] disk paths" 20

  try_silent_print_with_exit \
    "sed -i '' '/\/dev\/gpt\/${gpt_swap_part_label}/d' /etc/fstab" \
    "Removing any existing /etc/fstab swap entry for /dev/gpt/${gpt_swap_part_label}" 20

  try_silent_print_with_exit \
    "echo '/dev/gpt/${gpt_swap_part_label} none swap sw 0 0' >> /etc/fstab" \
    "Adding ${gpt_swap_part_label} swap entry to /etc/fstab" 20

  try_silent_print_with_exit \
    "swapon -a" \
    "Activating all swap devices listed in /etc/fstab" 20
}

geli_encrypt_labeled_zfs_part_as_req() {
  gpt_part_label_path="${1}"

  if [ "${ENCRYPTION_PASSWORD}" != '' ]; then
    temp_enc_passwd_file="/tmp/geli_enc_zfs_part_pass.txt"

    try_silent_with_exit \
      "printf \"%s\" ${ENCRYPTION_PASSWORD} > \"${temp_enc_passwd_file}\"" \
      "error writing encryption password into temp file" 20

    try_silent_print_with_exit \
      "geli init -g -J \"${temp_enc_passwd_file}\" \"${gpt_part_label_path}\"" \
      "initializing encrypted GELI device on new zfs partition" 20

    try_silent_print_with_exit \
      "geli attach -j \"${temp_enc_passwd_file}\" \"${gpt_part_label_path}\"" \
      "attaching encrypted GELI device to system" 20

    try_silent_with_exit \
      "rm \"${temp_enc_passwd_file}\"" \
      "error removing encryption password temp file" 20
  fi
}

attach_new_device_to_existing_zfs_device_in_mirror() {
  new_device_path="${1}"
  existing_zfs_device_path="${2}"
  pool="${3}"

  printf "NOTE: the following attach operation waits for the new zfs device to resilver, "
  printf "and can take 10 - 30 minutes, depending on disk size.\n"
  try_silent_print_with_exit \
    "zpool attach -f -w ${pool} \"${existing_zfs_device_path}\" \"${new_device_path}\"" \
    "attaching new device to existing zfs device, to create or extend the mirror," 60
}

exec_detach_device_from_mirror() {
  device="${1}"
  pool="${2}"

  try_silent_print_with_exit \
    "zpool detach ${pool} ${device}" \
    "detaching zfs device \"${device}\" from mirror" 10
}

exec_offline_device_from_pool() {
  device="${1}"
  pool="${2}"

  try_silent_print_with_exit \
    "zpool offline ${pool} ${device}" \
    "offlining zfs device \"${device}\"" 10
}

exec_attach_new_disk_to_install_mirror() {
  new_disk_path="${1}"
  zfs_device_path="${2}"
  pool="${3}"

  validate_not_active_device_in_vdev "${new_disk_path}"
  validate_active_device_in_vdev "${zfs_device_path}" "${pool}"
  validate_item_is_not_full_disk "${zfs_device_path}"
  # Note: as of Jan 2025, GELI attaches only to raw disk devices, not labels.
  # zpool status will show labels after this operation, but they'll disappear on
  # the next boot.
  # Ref: https://forums.freebsd.org/threads/geom-labels-disappear-after-geli-attaches-to-raw-disk-device.89579/#post-615626
  validate_not_gpt_partition_label "${zfs_device_path}"

  wipe_new_disk_as_required "${new_disk_path}"
  format_partitions_on_new_root_mirror_disk "${new_disk_path}" "${zfs_device_path}"
  configure_boot_partitions_on_new_root_mirror_disk "${new_disk_path}"
  configure_swap_partition_on_new_root_mirror_disk "${new_disk_path}"
  label_existing_zfs_partition "${new_disk_path}"
  gpt_part_label_path="$(print_gpt_zfs_part_label_path "${new_disk_path}")"
  geli_encrypt_labeled_zfs_part_as_req "${gpt_part_label_path}"
  enc_mod_part_label_path="$(print_enc_mod_gpt_partition_label_path "${gpt_part_label_path}")"

  attach_new_device_to_existing_zfs_device_in_mirror \
    "${enc_mod_part_label_path}" \
    "${zfs_device_path}" \
    "${pool}"
}

exec_attach_new_disk_to_boot_mirror() {
  new_disk_path="${1}"
  gpt_label_path="${2}"
  pool="${3}"

  validate_not_active_device_in_vdev "${new_disk_path}"
  validate_active_device_in_vdev "${gpt_label_path}" "${pool}"

  wipe_new_disk_as_required "${new_disk_path}"
  format_partitions_on_new_root_mirror_disk "${new_disk_path}" "${gpt_label_path}"
  configure_boot_partitions_on_new_root_mirror_disk "${new_disk_path}"
  configure_swap_partition_on_new_root_mirror_disk "${new_disk_path}"
  label_existing_zfs_partition "${new_disk_path}"
  gpt_part_label_path="$(print_gpt_zfs_part_label_path "${new_disk_path}")"
  geli_encrypt_labeled_zfs_part_as_req "${gpt_part_label_path}"
  enc_mod_part_label_path="$(print_enc_mod_gpt_partition_label_path "${gpt_part_label_path}")"

  attach_new_device_to_existing_zfs_device_in_mirror \
    "${enc_mod_part_label_path}" \
    "${gpt_label_path}" \
    "${pool}"
}

do_print_help_menu() {
  print_usage
}

do_list_pools_status() {
  pools_status="$(zpool list -L -P -v)"
  quit_if_rc_not_zero "${?}" "error getting zpool status" 5
  printf "*********** STATUS OF ALL POOLS, ALONG WITH THEIR VDEVS AND DEVICES ***********\n"
  printf "%s\n" "${pools_status}"

  pools_health="$(zpool get -H -o value health)"
  quit_if_rc_not_zero "${?}" "error getting zpool health" 5
  printf "%s\n" "${pools_health}" | while IFS="$(printf "\n.")" read -r line; do
    if [ "${line}" != 'ONLINE' ]; then
      quit_with_err_msg "one or more devices in a pool's vdev is not online" 1
    fi
  done
}

do_create_storage_pool() {
  check_running_as_root
  check_whole_disk_option
  check_pool_option_is_not_boot_pool "${POOL}"

  validate_not_active_device_in_vdev "${NEW_DISK_PATH}"

  wipe_new_disk_as_required "${NEW_DISK_PATH}"
  create_single_zfs_partition "${NEW_DISK_PATH}"
  gpt_part_label_path="$(print_gpt_zfs_part_label_path "${NEW_DISK_PATH}")"

  mount_point="$(print_perm_mount_point "${DEFAULT_PERM_MOUNT_POINT_BASE}" "${PERM_MOUNT_POINT}" "${POOL}")"
  try_silent_print_with_exit \
    "zpool create -f -m \"${mount_point}\" ${POOL} \"${gpt_part_label_path}\"" \
    "creating new storage pool from single disk \"${NEW_DISK_PATH}\", mounted at \"${mount_point}\"," 80
}

do_attach_new_disk_to_boot_mirror() {
  check_running_as_root
  check_whole_disk_option
  check_gpt_label_option
  check_encrypt_pswd_option_supplied_if_req "${GPT_LABEL_PATH}" "--gpt-label"
  check_pool_option_is_boot_pool "${POOL}"

  exec_attach_new_disk_to_boot_mirror "${NEW_DISK_PATH}" "${GPT_LABEL_PATH}" "${POOL}"
}

do_attach_new_disk_to_storage_mirror() {
  check_running_as_root
  check_whole_disk_option
  check_gpt_label_option
  check_encrypt_pswd_option_is_not_specified
  check_pool_option_is_not_boot_pool "${POOL}"

  validate_not_active_device_in_vdev "${NEW_DISK_PATH}"
  validate_active_device_in_vdev "${GPT_LABEL_PATH}" "${POOL}"

  wipe_new_disk_as_required "${NEW_DISK_PATH}"
  create_single_zfs_partition "${NEW_DISK_PATH}"
  gpt_part_label_path="$(print_gpt_zfs_part_label_path "${NEW_DISK_PATH}")"

  attach_new_device_to_existing_zfs_device_in_mirror \
    "${gpt_part_label_path}" \
    "${GPT_LABEL_PATH}" \
    "${POOL}"
}

do_detach_disk_from_mirror() {
  check_running_as_root
  check_gpt_label_option

  validate_active_device_in_vdev "${GPT_LABEL_PATH}" "${POOL}"

  exec_offline_device_from_pool "${GPT_LABEL_PATH}" "${POOL}"
  exec_detach_device_from_mirror "${GPT_LABEL_PATH}" "${POOL}"
}

do_add_vdev_to_storage_pool() {
  check_running_as_root
  check_zfs_device_option_is_not_specified
  check_whole_disk_option
  check_encrypt_pswd_option_is_not_specified
  check_pool_option_is_not_boot_pool "${POOL}"

  validate_not_active_device_in_vdev "${NEW_DISK_PATH}"

  wipe_new_disk_as_required "${NEW_DISK_PATH}"
  create_single_zfs_partition "${NEW_DISK_PATH}"
  gpt_part_label_path="$(print_gpt_zfs_part_label_path "${NEW_DISK_PATH}")"

  try_silent_print_with_exit \
    "zpool add ${POOL} \"${gpt_part_label_path}\"" \
    "adding disk \"${gpt_part_label_path}\" to pool \"${POOL}\" as single-disk vdev" 120
}

do_add_read_cache_disk_to_pool() {
  check_running_as_root
  check_whole_disk_option

  validate_not_active_device_in_vdev "${NEW_DISK_PATH}"

  wipe_new_disk_as_required "${NEW_DISK_PATH}"
  create_single_zfs_partition "${NEW_DISK_PATH}"
  gpt_part_label_path="$(print_gpt_zfs_part_label_path "${NEW_DISK_PATH}")"

  try_silent_print_with_exit \
    "zpool add ${POOL} cache \"${gpt_part_label_path}\"" \
    "adding read cache disk \"${gpt_part_label_path}\" to pool \"${POOL}\"" 60
}

do_remove_read_cache_disk_from_pool() {
  check_running_as_root
  check_gpt_label_option

  validate_active_device_in_vdev "${GPT_LABEL_PATH}" "${POOL}"
  validate_not_active_non_cache_device_in_vdev "${GPT_LABEL_PATH}" "${POOL}"
  validate_pool_has_read_cache_disk "${POOL}"

  try_silent_print_with_exit \
    "zpool remove -w ${POOL} ${GPT_LABEL_PATH}" \
    "removing read-cache disk \"${GPT_LABEL_PATH}\" from pool \"${POOL}\"" 120
}

do_add_write_cache_disk_to_pool() {
  check_running_as_root
  check_whole_disk_option

  validate_not_active_device_in_vdev "${NEW_DISK_PATH}"

  wipe_new_disk_as_required "${NEW_DISK_PATH}"
  create_single_zfs_partition "${NEW_DISK_PATH}"
  gpt_part_label_path="$(print_gpt_zfs_part_label_path "${NEW_DISK_PATH}")"

  try_silent_print_with_exit \
    "zpool add ${POOL} log \"${gpt_part_label_path}\"" \
    "adding write cache disk \"${gpt_part_label_path}\" to pool \"${POOL}\"" 60
}

do_attach_new_disk_to_write_cache_mirror() {
  check_running_as_root
  check_whole_disk_option
  check_gpt_label_option
  check_encrypt_pswd_option_is_not_specified

  validate_not_active_device_in_vdev "${NEW_DISK_PATH}"
  validate_active_device_in_vdev "${GPT_LABEL_PATH}" "${POOL}"
  validate_pool_has_write_cache_disk "${POOL}"

  wipe_new_disk_as_required "${NEW_DISK_PATH}"
  create_single_zfs_partition "${NEW_DISK_PATH}"
  gpt_part_label_path="$(print_gpt_zfs_part_label_path "${NEW_DISK_PATH}")"

  attach_new_device_to_existing_zfs_device_in_mirror \
    "${gpt_part_label_path}" \
    "${GPT_LABEL_PATH}" \
    "${POOL}"
}

do_remove_write_cache_vdev_from_pool() {
  check_running_as_root
  check_vdev_option

  validate_pool_has_write_cache_disk "${POOL}"

  try_silent_print_with_exit \
    "zpool remove -w ${POOL} ${ZFS_VDEV}" \
    "removing write-cache vdev \"${ZFS_VDEV}\" from pool \"${POOL}\"" 120
}

do_label_devices_in_install_mirror() {
  check_running_as_root
  check_vdev_option
  check_pool_option_is_boot_pool "${POOL}"
  check_encrypt_pswd_option_is_not_specified

  mirror_device_list="$(zpool get -Ho value children "${POOL}" "${ZFS_VDEV}")"
  disk_part_1="$(printf "%s" "${mirror_device_list}" | awk -F ',' '{ print $1 }')"
  disk_part_2="$(printf "%s" "${mirror_device_list}" | awk -F ',' '{ print $2 }')"
  whole_disk_1="$(print_whole_disk_path "${disk_part_1}")"
  whole_disk_2="$(print_whole_disk_path "${disk_part_2}")"

  if [ "${disk_part_1}" = '' ] || \
     [ "${disk_part_2}" = '' ]; then
    quit_with_err_msg "--zfs-vdev must be a mirror vdev with two devices" 1
  fi
  validate_partition_without_extension "${disk_part_1}"
  validate_partition_without_extension "${disk_part_2}"

  exec_offline_device_from_pool "${disk_part_2}" "${POOL}"
  exec_detach_device_from_mirror "${disk_part_2}" "${POOL}"
  exec_attach_new_disk_to_install_mirror "${whole_disk_2}" "${disk_part_1}" "${POOL}"

  disk_label_2="$(print_gpt_zfs_part_label_path "${whole_disk_2}")"
  exec_offline_device_from_pool "${disk_part_1}" "${POOL}"
  exec_detach_device_from_mirror "${disk_part_1}" "${POOL}"
  exec_attach_new_disk_to_boot_mirror "${whole_disk_1}" "${disk_label_2}" "${POOL}"
}

do_list_importable_pools() {
  check_running_as_root

  printf "****** EXPORTED/DESTROYED/EXTERNALLY-ACTIVE POOLS AVAILABLE FOR IMPORT ********\n"

  exported_pools="$(zpool import 2>&1)"
  quit_if_rc_not_zero "${?}" "error getting zpool import" 5
  destroyed_pools="$(zpool import -D 2>&1)"
  quit_if_rc_not_zero "${?}" "error getting zpool import -D" 5

  no_pools_text='no pools available'
  no_exported_pools="$(printf "%s" "${exported_pools}" | grep -o "${no_pools_text}")"
  no_destroyed_pools="$(printf "%s" "${destroyed_pools}" | grep -o "${no_pools_text}")"

  if [ "${no_exported_pools}" = "${no_pools_text}" ] && \
     [ "${no_destroyed_pools}" = "${no_pools_text}" ]; then
    printf "No pools available for import.\n"
  else
    if [ "${no_exported_pools}" != "${no_pools_text}" ]; then
      printf "%s\n" "${exported_pools}"
    fi
    if [ "${no_destroyed_pools}" != "${no_pools_text}" ]; then
      printf "%s\n" "${destroyed_pools}"
    fi
  fi
}

do_import_pool() {
  check_running_as_root
  check_pool_option_is_not_boot_pool "${POOL}"
  check_encrypt_pswd_option_is_not_specified

  # force-import a pool that appears to be externally active/online
  opts="-f"
  # query user for encryption keys as required for pool datasets
  opts="${opts} -l"

  if [ "${IGNORE_IMPORT_ERRORS}" = 'true' ]; then
    # attempt to recover a non-importable pool by discarding last few transactions
    opts="${opts} -F"
    # ignore any missing SLOG device, possibly discarding some transactions
    opts="${opts} -m"
  fi

  pool_destroyed_name="$(zpool import -D 2>&1 | grep "pool:" | grep -o "\b${POOL}\b")"
  pool_destroyed_id="$(zpool import -D 2>&1 | grep "id:" | grep -o "\b${POOL}\b")"
  if [ "${pool_destroyed_name}" = "${POOL}" ] || \
     [ "${pool_destroyed_id}" = "${POOL}" ]; then
    opts="${opts} -D"
  fi

  if [ "${TEMP_POOL_NAME}" = '' ]; then
    opts="${opts} ${POOL}"
  else
    opts="${opts} -t"
    opts="${opts} -R \"/${DEFAULT_TEMP_MOUNT_POINT_BASE}/${TEMP_POOL_NAME}\""
    opts="${opts} ${POOL} ${TEMP_POOL_NAME}"
  fi

  try_silent_print_with_exit \
    "zpool import ${opts}" \
    "importing and activating pool \"${POOL}\"" 100
}

do_export_pool() {
  check_running_as_root
  check_pool_option_is_not_boot_pool "${POOL}"
  check_encrypt_pswd_option_is_not_specified

  try_silent_print_with_exit \
    "zpool export ${POOL}" \
    "exporting pool \"${POOL}\" (import later with \"--import-pool\" option)" 100
}

do_scrub_pool_data() {
  check_running_as_root

  try_silent_print_with_exit \
    "zpool scrub -w ${POOL}" \
    "scrubbing and repairing all data in pool" 100
}

do_offline_device_from_pool() {
  check_running_as_root
  check_zfs_device_option

  exec_offline_device_from_pool "${ZFS_DEVICE_PATH}" "${POOL}"
}

do_attach_new_disk_to_install_mirror() {
  check_running_as_root
  check_whole_disk_option
  check_zfs_device_option
  check_encrypt_pswd_option_supplied_if_req "${ZFS_DEVICE_PATH}" "--zfs-device"
  check_pool_option_is_boot_pool "${POOL}"

  exec_attach_new_disk_to_install_mirror "${NEW_DISK_PATH}" "${ZFS_DEVICE_PATH}" "${POOL}"
}

do_attach_device_as_is_to_mirror() {
  check_running_as_root
  check_device_option
  check_zfs_device_option
  check_pool_option_is_boot_pool "${POOL}"

  attach_new_device_to_existing_zfs_device_in_mirror \
    "${NON_ZFS_DEVICE_PATH}" \
    "${ZFS_DEVICE_PATH}" \
    "${POOL}"
}

do_online_device_into_pool() {
  check_running_as_root
  check_zfs_device_option

  try_silent_print_with_exit \
    "zpool online ${POOL} ${ZFS_DEVICE_PATH}" \
    "onlining zfs device" 60
}

do_detach_device_from_mirror() {
  check_running_as_root
  check_zfs_device_option

  exec_offline_device_from_pool "${ZFS_DEVICE_PATH}" "${POOL}"
  exec_detach_device_from_mirror "${ZFS_DEVICE_PATH}" "${POOL}"
}

do_remove_vdev_from_pool() {
  check_running_as_root
  check_vdev_option

  try_silent_print_with_exit \
    "zpool remove -w ${POOL} ${ZFS_VDEV}" \
    "removing vdev \"${ZFS_VDEV}\" from pool \"${POOL}\" and consolidating data into remaining vdevs" 120
}

do_destroy_pool() {
  check_running_as_root
  check_pool_option_is_not_boot_pool "${POOL}"

  try_silent_print_with_exit \
    "zpool destroy ${POOL}" \
    "destroying pool \"${POOL}\" (NOTE: it *can* be imported after destroy)" 120
}

# MAIN SCRIPT:

main() {
  get_cmd_opts "$@"

  if [ "${PRINT_HELP_MENU}" = 'true' ]; then
    do_print_help_menu
  elif [ "${LIST_POOLS_STATUS}" = 'true' ]; then
    do_list_pools_status
  elif [ "${CREATE_STORAGE_POOL}" = 'true' ]; then
    do_create_storage_pool
  elif [ "${ATTACH_NEW_DISK_TO_BOOT_MIRROR}" = 'true' ]; then
    do_attach_new_disk_to_boot_mirror
  elif [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ]; then
    do_attach_new_disk_to_storage_mirror
  elif [ "${DETACH_DISK_FROM_MIRROR}" = 'true' ]; then
    do_detach_disk_from_mirror
  elif [ "${ADD_VDEV_TO_STORAGE_POOL}" = 'true' ]; then
    do_add_vdev_to_storage_pool
  elif [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ]; then
    do_add_read_cache_disk_to_pool
  elif [ "${REMOVE_READ_CACHE_DISK_FROM_POOL}" = 'true' ]; then
    do_remove_read_cache_disk_from_pool
  elif [ "${ADD_WRITE_CACHE_DISK_TO_POOL}" = 'true' ]; then
    do_add_write_cache_disk_to_pool
  elif [ "${ATTACH_NEW_DISK_TO_WRITE_CACHE_MIRROR}" = 'true' ]; then
    do_attach_new_disk_to_write_cache_mirror
  elif [ "${REMOVE_WRITE_CACHE_VDEV_FROM_POOL}" = 'true' ]; then
    do_remove_write_cache_vdev_from_pool
  elif [ "${LABEL_DEVICES_IN_INSTALL_MIRROR}" = 'true' ]; then
    do_label_devices_in_install_mirror
  elif [ "${LIST_IMPORTABLE_POOLS}" = 'true' ]; then
    do_list_importable_pools
  elif [ "${IMPORT_POOL}" = 'true' ]; then
    do_import_pool
  elif [ "${EXPORT_POOL}" = 'true' ]; then
    do_export_pool
  elif [ "${SCRUB_POOL_DATA}" = 'true' ]; then
    do_scrub_pool_data
  elif [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ]; then
    do_offline_device_from_pool
  elif [ "${ATTACH_NEW_DEVICE_TO_INSTALL_MIRROR}" = 'true' ]; then
    do_attach_new_disk_to_install_mirror
  elif [ "${ATTACH_DEVICE_AS_IS_TO_MIRROR}" = 'true' ]; then
    do_attach_device_as_is_to_mirror
  elif [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    do_online_device_into_pool
  elif [ "${DETACH_DEVICE_FROM_MIRROR}" = 'true' ]; then
    do_detach_device_from_mirror
  elif [ "${REMOVE_VDEV_FROM_POOL}" = 'true' ]; then
    do_remove_vdev_from_pool
  elif [ "${DESTROY_POOL}" = 'true' ]; then
    do_destroy_pool
  else
    quit_with_err_msg "no valid option selected" 255
  fi

  exit_with_cleanup 0
}

main "$@"

